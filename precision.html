<html><head><title>niplav</title>
<link href="./favicon.png" rel="shortcut icon" type="image/png"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<!DOCTYPE HTML>

<style type="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>
<script async="" src="./mathjax/latest.js?config=TeX-MML-AM_CHTML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
	extensions: ["tex2jax.js"],
	jax: ["input/TeX", "output/HTML-CSS"],
	tex2jax: {
		inlineMath: [ ['$','$'], ["\\(","\\)"] ],
		displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
		processEscapes: true,
		skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
	},
	"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>
<script>
document.addEventListener('DOMContentLoaded', function () {
	// Change the title to the h1 header
	var title = document.querySelector('h1')
	if(title) {
		var title_elem = document.querySelector('title')
		title_elem.textContent=title.textContent + " – niplav"
	}
});
</script>
</head><body><h2><a href="./index.html">home</a></h2>
<p><em>author: niplav, created: 2022-02-04, modified: 2023-06-12, language: english, status: notes, importance: 4, confidence: likely</em></p>
<blockquote>
<p><strong>I discuss proposals for a function that estimates how much predictive
information additional degrees of precision in forecasts add and at which
point additional precision is just noise, and investigate these proposals
with empirical forecasting data. I furthermore describe desirable criteria
such functions ought to fulfill.</strong></p>
</blockquote>
<!--https://nitter.net/tenthkrige/status/1412457737380839432-->
<!--https://stanford.edu/~knutson/nfc/mellers15.pdf-->
<!--https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/D9FAZL-->
<h1 id="Precision_of_Sets_of_Forecasts"><a class="hanchor" href="#Precision_of_Sets_of_Forecasts">Precision of Sets of Forecasts</a></h1>
<p><em>epistemic status: likely not just reinventing the wheel, but the whole bicycle</em></p>
<p>Say we have a set of resolved forecasts and can display them on a
calibration plot.</p>
<p>We can grade the forecasts according to some proper scoring rule,
e.g. the <a href="https://en.wikipedia.org/wiki/Brier_score">Brier score</a>
or the <a href="https://en.wikipedia.org/wiki/Scoring_rule#Logarithmic_scoring_rule">logarithmic scoring
rule</a>.</p>
<p>But we can also ask the question: how fine-grained are the predictions of
our forecaster? I.e., at which level of precision can we assume that
the additional information is just noise?</p>
<h3 id="Overprecise_Omar"><a class="hanchor" href="#Overprecise_Omar">Overprecise Omar</a></h3>
<p>Take, for example, a hypothetical forecaster Omar who always gives
their forecasts with 5 decimal digits of precision, such as forecasting a
"24.566% probability of North Korea testing an ICBM in the year 2022",
even though if we look at their calibration plot (of sufficiently many
forecasts), we see that they are pretty much random in any given interval
of length 0.1 (i.e., their forecast with 15% and a forecast of 5% can
be expected to resolve to the same outcome with equal probability). This
means that 4 of the 5 decimal digits of precision are likely just noise!</p>
<p>Omar would be behaving absurdly; misleading their audience into
believing they had spent much more time on their forecasts than they
actually had (or, more likely, into correctly leading the audience into
believing that there was something epistemically sketchy going on).</p>
<p>I believe something similar is going on when people encounter
others putting probabilities on claims: It appears like an attempt
at claiming undue quantitativeness (quantitativity?) in their
reasoning, and at making the listener fall prey to <a href="https://en.wikipedia.org/wiki/Precision_bias">precision
bias</a>,
as well as an implicit claim at scientific
rigour. However, not all precision in prediction is <a href="https://en.wikipedia.org/wiki/False_precision">false
precision</a>: At some
point, if remove digits of precision, the forecasts will become worse
in expectation.</p>
<p>But how might we confront our forecaster Omar from above? How might we
estimate the level of degrees of precision after which their forecasts
gave no more additional information?</p>
<h2 id="Definitions"><a class="hanchor" href="#Definitions">Definitions</a></h2>
<p>Ideally we'd want to find a number that tells us, for a given set of
prediction, the precision that those predictions display: Any additional
digits added to the probability beyond this precision would just be noise.</p>
<p>Let us call this number the precision <code>$ᚠ$</code> of a set of forecasts.</p>
<p>Let <code>$\mathbf{D}=((f_1, o_1), \dots, (f_n, o_n)) \in ((0,1),\{0,1\})^n$</code>
be a dataset of <code>$n$</code> forecasts <code>$f_i$</code> and resolutions <code>$o_i$</code>.</p>
<p>Then <code>$ᚠ$</code> is simply a function that takes in such a dataset of
forecasts and produces a real number <code>$ᚠ: ((0;1),\{0,1\})^n \rightarrow
\mathbb{R}$</code>, so for example <code>$ᚠ(D)=0.8$</code> for the forecasts and outcomes
<code>$D$</code> of some forecaster, or team of forecasters.</p>
<h3 id="Bits_Not_Probabilities_for_Precision"><a class="hanchor" href="#Bits_Not_Probabilities_for_Precision">Bits, Not Probabilities, for Precision</a></h3>
<p>It is natural to assume that <code>$ᚠ$</code> returns a <em>probability</em>:
after all, the input dataset has probabilities, and
when talking about <a href="#Overprecise_Omar">Omar's</a> <a href="https://en.wikipedia.org/wiki/Probabilistic_classification#Probability_calibration">calibration
plot</a>
I was explicitely calling out the loss of accuracy in probability
intervals shorter than 0.1.</p>
<p>Furthermore, Tetlock et al.<!--TODO: read &amp; link their precision paper-->
also talk about precision in terms of probabilities, we are all used to
probabilities, probabilities are friends.</p>
<p>But this doesn't stand up to scrutiny: If we accept this,
assuming we use probability buckets of size 5%, then 99.99999%
and 96% are as similar to each other as 51% and 54.99999%. But the
readers familiar with the formulation of probability in <a href="https://en.wikipedia.org/wiki/Logit">log-odds
form</a> surely balk at this
equivalence: 99.99999% is a beast of a probability, an invocation only
uttered in situations of extreme certainty, while 96%, 51% and 54.99999%
(modulo false precision) are everyday probabilities, plebeian even.</p>
<p>However, in terms of <em>precision</em>, 54.99999% stands out
like a sore thumb: while 99.99999% is supremely confident,
it is not <em>overprecise</em>, since rounding up to 100% <a href="https://www.lesswrong.com/posts/QGkYCwyC7wTDyt3yT/0-and-1-are-not-probabilities">would be
foolish</a>;
but with 54.99999%, there is no good reason we can't just round to 55%.</p>
<p>So precision should be calculated in log-odds space, where one moves in
bits instead of probabilities. Since we want to make a statement how
much we can move the probabilities around until the <a href="https://en.wikipedia.org/wiki/Scoring_rule">proper scoring
rule</a> we apply starts
giving worse results, it is only natural to express the precision in
bits as well. (Which can't be converted linearly into probabilities:
moving from 50% to 75% is one bit, but similarly moving from ~99.954%
to ~99.977% is also a change of one bit).<!--TODO: check whether example
is actually correct--></p>
<h2 id="Algorithms"><a class="hanchor" href="#Algorithms">Algorithms!</a></h2>
<p>The assumption of expressing precision in bits naturally leads to an
algorithm:</p>
<ol>
<li>Transform the dataset of forecasts <code>$D$</code> into log-odds.</li>
<li>Apply some noise <code>$ⴟ(θ)$</code> for some parameters <code>$θ$</code> to those forecasts.</li>
<li>Transform those the forecasts back to probabilities.</li>
<li>Check whether this noising has changed the score for the forecasts.</li>
<li>If 4. hasn't determined the precision at which forecasts in <code>$D$</code> receive worse scores, change <code>$θ$</code> and go back to step 1.</li>
<li>Else convert <code>$ⴟ(θ)$</code> into an estimate of precision and return it.</li>
</ol>
<p>This has some free parameters (Which noise function <code>$ⴟ(θ)$</code>
<em>exactly</em> does one use? How does one change <code>$θ$</code> at the end of each
iteration?) and is potentially quite resource intensive (potentially
requiring many samples to find the correct <code>$θ$</code>).</p>
<p>Uniform noise (in both directions) is easiest to interpret: The "width"
of the noise is then the precision that is being investigated.</p>
<!--TODO: image of uniform noise at various points on the log-odds
curve-->
<p>So one can first define some helper functions</p>
<pre><code>import csv
import statistics
import numpy as np

def mse(o,p):
    return np.mean(np.abs(o-p)**2)

def logit(p):
    return np.log(p/(1-p))

def logistic(p):
    return 1/(1+np.exp(-p))
</code></pre>
<p>and then a simple function that</p>
<pre><code>def perturbed_score_difference(forecasts, perturbation=1, samples=1000):
    o=forecasts[0]
    p=forecasts[1]
    score=mse(o,p)
    pert_scores=[]
    for i in range(0,samples):
        perturbed=logistic(logit(p)+np.random.default_rng().uniform(-perturbation/2,perturbation/2,len(p)))
        pert_scores.append(mse(o,perturbed))
    return np.mean(pert_scores)-score
</code></pre>
<p>One could then simply sample the precisions and estimate the <a href="https://en.wikipedia.org/wiki/Knee_of_a_curve">elbow
point</a> with a threshold
value (why doesn't <code>range</code> allow floating point values as parameters?):</p>
<pre><code>def score_differences(forecasts, samples=100, low=0, high=100, div=100):
    return np.array([[s/div, perturbed_score_difference(d1, perturbation=s/div, samples=samples)] for s in range(low,high)]).T
</code></pre>
<p>We can now define a toy dataset to visualize the differences in Brier
score of the perturbed data and the unperturbed data:</p>
<pre><code>d1=np.array([[1,0.8],[0,0.4],[0,0.65],[1,0.99]]).T
oc=d1[0]
pr=d1[1]

d2=np.array([[1,0.8],[0,0.4],[0,0.65],[1,0.9]]).T
oc2=d1[0]
pr2=d1[1]

d3=np.array([[0,0.8],[1,0.4],[1,0.65],[0,0.9]]).T
oc3=d1[0]
pr3=d1[1]
</code></pre>
<p>Then we can set</p>
<pre><code>differences1=score_differences(d1, samples=5000, low=0, high=50, div=50)
differences2=score_differences(d1, samples=5000, low=0, high=50, div=50)
differences3=score_differences(d1, samples=5000, low=0, high=50, div=50)
</code></pre>
<p>and plot the result:</p>
<p><img alt="" src="./img/precision/toy_elbow.png" title=""/><!--TODO: plot description--></p>
<p>One can now eyeball this plot and try to determine the point where the
difference in Brier score starts diverging from 0, which I would put at
around 0.25 bits.</p>
<h2 id="Appendix_A_Conditions_for_a_Precision_Evaluation_Function"><a class="hanchor" href="#Appendix_A_Conditions_for_a_Precision_Evaluation_Function">Appendix A: Conditions for a Precision Evaluation Function</a></h2>
<p>Use precision <code>$ᚠ$</code> and noise <code>$ⴟ$</code>.</p>
<ol>
<li>If <code>$n=0$</code>, <code>$s(\emptyset, \mathcal{F})$</code> is undefined.</li>
<li>If <code>$n=1$</code>, <code>$s(\mathbf{D}, \mathcal{F})=0$</code>: We are generally suspicious of any single forecast.
<ol>
<li>More generally, if <code>$\mathbf{D}$</code> contains an <code>$f_i$</code> so that there is no other prediction with a probability within <code>$[f_i-\frac{\mathcal{F}}{2}; f_i+\frac{\mathcal{F}}{2}]$</code>, then <code>$s(\mathbf{D}, \mathcal{F})=0$</code>. Yes, even if the set of forecasts is "dense" and non-random in other places.</li>
</ol></li>
<li>If <code>$n=2$</code>, then it should hold for an <code>$ε&gt;0$</code> (but close to 0): <code>$s(((ε, 0), (1-ε, 1)), 1)=1$</code>, and <code>$s(((ε, 0), (1-ε, 1)), 0.5)=0$</code>.
<ol>
<li>More generally, if we have only zeros in the left half and ones in the right half, with <code>$n \rightarrow \infty$</code>, and a sufficiently small <code>$\frac{1}{n}&gt;ε&gt;0$</code>, it should hold that <code>$s(((ε,0),(2ε,0), \dots, (\lfloor \frac{n}{2} \rfloor ε, 0), (\lceil \frac{n}{2} \rceil ε, 1), \dots, (nε, 1)), \mathcal{F})$</code> is <code>$1$</code> for <code>$\mathcal{F}=1$</code> and <code>$0$</code> for <code>$\mathcal{F} \le 0.5$</code>.</li>
</ol></li>
<li>For a sufficiently large <code>$n \rightarrow \infty$</code>, and a sufficiently small <code>$\frac{1}{n}&gt;ε&gt;0$</code>, and <code>$r(p)$</code> being 1 with probability <code>$p$</code> and 0 with probability <code>$1-p$</code>, it should hold that <code>$s(((ε,r(ε)),(2ε,r(2ε)), \dots, (\lfloor \frac{n}{2} \rfloor ε, r(\lfloor \frac{n}{2} \rfloor ε)), (\lceil \frac{n}{2} \rceil ε, r(\lceil \frac{n}{2} \rceil ε)), \dots, (nε, r(nε))), \mathcal{F})=1$</code> for any <code>$\mathcal{F}$</code>: If we have lots of datapoints, all perfectly calibrated, the score is nearly 0 at all precisions.</li>
<li>In expectation, if we sample every <code>$o_i$</code> uniformly from <code>$\{0, 1\}$</code> with replacement, <code>$s(\mathbf{D}, \mathcal{F})=0$</code>.</li>
<li>With <code>$\mathcal{F}_1&lt;\mathcal{F}_2$</code>, <code>$s(\mathbf{D}, \mathcal{F}_1) \le s(\mathbf{D}, \mathcal{F}_2)$</code> (smaller precision shouldn't lead to a greater score, since if you're uncalibrated at a precision of 10%, you're not going to be suddenly calibrated at a precision of 5%)
<ol>
<li>We can't just do this by multiplying the result with the precision, since that would violate condition 4</li>
</ol></li>
</ol>
<p>But what should be done about a calibration plot that looks like this?</p>
<p><img alt="A lopsided calibration plot: Linear and ascending up to 0.5, and then linearly descending to 0" src="./img/precision/cap.png" title="A lopsided calibration plot: Linear and ascending up to 0.5, and then linearly descending to 0"/></p>
<p>There are two ways of arguing what, morally, the precision of the
forecasts is:</p>
<ul>
<li>The argument <em>for</em> having a score of <code>$~1$</code> for every precision (assuming a large <code>$n$</code>) is that inferring the correct way to make forecasts from this calibration plot is trivial: With forecasts of probability <code>$f_i&gt;0.5$</code>, re-assign a probability <code>$f_i:=1-f_i$</code>.</li>
<li>The argument <em>against</em> giving a score of <code>$~1$</code> is that extending this rule would mean that at every kind of correction on the plot is valid, but there is no clear cutoff point that prevents us from applying this to individual predictions ("If you predict 99% instead of 43%, and 1% instead of 13%, and 1% instead of 23%, and […], then you achieve perfect resolution and calibration.")</li>
</ul>
<h2 id="Appendix_B_Further_Idea_Sketches_for_Algorithms"><a class="hanchor" href="#Appendix_B_Further_Idea_Sketches_for_Algorithms">Appendix B: Further Idea Sketches for Algorithms</a></h2>
<ul>
<li>Algorithms for quantifying the precision of calibration plots
<ul>
<li>Input: A list of <code>n</code> forecasts and their resolutions</li>
<li>First idea:
<ul>
<li>For i=2, n
<ul>
<li>Segment the forecasts into i different segments, ordered by probability</li>
<li>Calculate average outcome</li>
<li>For two adjacent segments, calculate the slope for those values</li>
<li>Append the mean of all slopes of adjacent segments to the array <code>output</code></li>
</ul></li>
<li>Return <code>output</code></li>
</ul></li>
<li>Second idea:
<ul>
<li>For i=2, n
<ul>
<li>Segment the forecasts into i different segments, ordered by probability</li>
<li>Re-scale each segment to give probabilities from 0 to 1</li>
<li>Use a proper scoring rule? Idk I haven't thought this through</li>
</ul></li>
</ul></li>
<li>Third idea:
<ul>
<li>Something like the first idea, but with a sliding window</li>
</ul></li>
<li>Fourth idea:
<ul>
<li>Average linear regression of all subsequences with length<code>$\ge \mathcal{F}$</code></li>
</ul></li>
</ul></li>
<li>Start with perfect predictor, the level of noise at which its Brier score is equal to the dataset</li>
<li>Additional ideas:
<ul>
<li>Multiply score with the average number of datapoints inside the given precision</li>
</ul></li>
</ul>
</body></html>
