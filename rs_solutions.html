
<title>niplav</title>
<link rel="shortcut icon" type="image/png" href="./favicon.png">
<link rel="stylesheet" type="text/css" href="main.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!DOCTYPE HTML>

<style TYPE="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>

<script type="text/javascript" async
	src="./mathjax/latest.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
	extensions: ["tex2jax.js"],
	jax: ["input/TeX", "output/HTML-CSS"],
	tex2jax: {
		inlineMath: [ ['$','$'], ["\\(","\\)"] ],
		displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
		processEscapes: true,
		skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
	},
	"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>

<script>
var anchorhash={}
function addAnchor(element) {
	var cnt=element.textContent
	if(cnt==="home")
		return;
	var ref=element.textContent.replace(/[^a-zA-Z0-9 ]/mg, "")
	ref=ref.replace(/ /mg, "-")
	var newref=ref;
	if(anchorhash[ref]===1)
		for(i=1, newref=ref+"_"+i;anchorhash[ref+"_"+i]===1;i++, newref=ref+"_"+i)
			;
	ref=newref
	element.setAttribute("id", `${ref}`)
	element.innerHTML=`<a href="#${ref}" class="hanchor">${cnt}</a>`
	anchorhash[ref]=1
}
document.addEventListener('DOMContentLoaded', function () {
	// Add anchor links to all headings
	var headers = document.querySelectorAll('h1, h2, h3, h4, h5, h6')
	if (headers) {
		headers.forEach(addAnchor)
	}
	// Change the title to the h1 header
	var title = document.querySelector('h1')
	if(title) {
		var title_elem = document.querySelector('title')
		title_elem.textContent=title.textContent + " – niplav"
	}
});
</script>

<h2><a href="./index.html">home</a></h2>

<p><em>author: niplav, created: 2021-10-14, modified: 2021-11-01, language: english, status: in progress, importance: 2, confidence: likely</em></p>

<blockquote>
  <p><strong>.</strong></p>
</blockquote>

<h1>Solutions to “Reactive Systems”</h1>

<h2>Chapter 2</h2>

<h3>2.1</h3>

<blockquote>
  <p>Give a CCS process which describes a clock that ticks at least once
and may stop ticking after each clock tick.</p>
</blockquote>

<p><code>$\text{Clock} \overset{\text{def}}{=} (\text{tick}.\mathbf{0}+\text{tick}.\text{Clock})$</code></p>

<h3>2.2</h3>

<blockquote>
  <p>Give a CCS process which describes a coffee machine that may behave
like that given by (2.1) but may also steal the money it receives and
fail at any time.</p>
</blockquote>

<p>This exercise is not quite well-defined. Should it sometimes take the
money and offer nothing in return, but continue functioning, or should
it actually fail sometimes and break down? The former case would be
described by</p>

<p><code>$\text{CTM} \overset{\text{def}}{=} \text{coin}.(\text{CTM}+\overline{\text{coffee}}.\text{CTM}+\overline{\text{tea}}.\text{CTM})$</code>,</p>

<p>the latter by</p>

<p><code>$\text{CTM} \overset{\text{def}}{=} \text{coin}.(\text{CTM}+\mathbf{0}+\overline{\text{coffee}}.\text{CTM}+\overline{\text{tea}}.\text{CTM})$</code></p>

<p>Hey look! <code>$+$</code> is commutative here!</p>

<h3>2.3</h3>

<blockquote>
  <p>A finite process graph <code>$T$</code> is a quadruple <code>$(\mathcal{Q}, A, \delta, q_0)$</code>, where <br />
• <code>$\mathcal{Q}$</code> is a finite set of states, <br />
• <code>$A$</code> is a finite set of labels, <br />
• <code>$q_0 \in \mathcal{Q}$</code> is the start state, and <br />
• <code>$\delta: \mathcal{Q} \times A \rightarrow 2^{\mathcal{Q}}$</code> is the transition function.  </p>

<p>Using the operators introduced so far, give a CCS process that describes <code>$T$</code>.</p>
</blockquote>

<div>
    $$ T=q_0.\underset{a_1 \in A}{\mathbf{+}} (a_1. \underset{q_1 \in δ(q_0, a_1)}{\mathbf{+}} (q_1.\underset{a_2 \in A}{\mathbf{+}} (a_2. \underset{q_2 \in δ(q_1, a_2)}{\mathbf{+}} (q_2. \cdots))))$$
</div>

<p>where <code>$\mathbf{+}$</code> is <em>supposed</em> to be a big iterative operator like
<code>$\sum$</code>, if only I could get MathJax to accept <code>\scalerel</code>. The equation
is nested infinitely deep at most places that result in a loop that
doesn't include <code>$q_0$</code>, and in some places end with <code>$.T$</code>, if <code>$q_0
\in δ(q_n,a)$</code>.</p>

<h3>2.4</h3>

<blockquote>
  <p>Consider the following LTS:</p>
</blockquote>

<p><img src="./img/rs_solutions/diagram_2_4.png" alt="A cyclic diagram for exercise 2.4, described further below." title="A cyclic diagram for exercise 2.4, described further below." /></p>

<blockquote>
  <p>Define the LTS as a triple
<code>$(\text{Proc}, \text{Act}, \{\overset{α}{\rightarrow}|α \in \text{Act}\})$</code>.
Use sketches to illustrate the reflexive closure, symmetric closure and
transitive closure of the binary relation <code>$\overset{α}{\rightarrow}$</code>?</p>
</blockquote>

<p>The process, in triple form, is
<code>$(\{s, s_1, s_2, s_3\}, \{a\}, \overset{a}{\rightarrow}=\{(s, s_1), (s_1, s_2), (s_2, s_3), (s_3, s)\})$</code>.</p>

<p>I'm not sure about the sketch part, but I can try to describe the
different closures.</p>

<p>The reflexive closure of <code>$\overset{a}{\rightarrow}$</code> would additionally
contain the elements
<code>$\{(s,s), (s_1, s_1), (s_2, s_2), (s_3, s_3)\}$</code>.</p>

<p>The symmetric closure is similarly easy to generate: it additionally
contains the elements <code>$\{(s_1, s), (s_2, s_1), (s_3, s_2), (s, s_3)\}$</code>.</p>

<p>The transitive closure additionally contains the elements from the set
<code>$\{(s, s_2), (s, s_3), (s_1, s_3), (s_1, s), (s_2, s), (s_2, s_1), (s_3, s_1), (s_3, s_2)\}$</code>.</p>

<h3>2.5</h3>

<p>The set of reachable states includes all states: <code>$p, p_1$</code> and <code>$p_2$</code>.</p>

<h3>2.6</h3>

<ul>
<li><code>$a.b.A+B$</code> ✓</li>
<li><code>$(a.\mathbf{0}.\overline{a}.A)\backslash \{a,b\}$</code> ✓</li>
<li><code>$(a.\mathbf{0}|\overline{a}.A)\backslash \{a,τ\}$</code> ✗: <code>$τ$</code> can't be excluded</li>
<li><code>$a.B+[a/b]$</code> ✗: a renaming is not a process</li>
<li><code>$τ.τ.B+\mathbf{0}$</code> ✓</li>
<li><code>$(a.B+b.B)[a/b, b/a]$</code> ✓</li>
<li><code>$(a.B+τ.B)[a/τ, b/a]$</code> ✓</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0})|B$</code> ✓</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0}).B$</code> ✗: the object in the parentheses is not a label, but a process</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0})+B$</code> ✓</li>
<li><code>$(\mathbf{0}|\mathbf{0})+\mathbf{0}$</code> ✓</li>
</ul>

<h3>2.7</h3>

<blockquote>
  <p>Use the rules of SOS semantics for CCS to derive the LTS for the
process <code>$\text{SmUni}$</code> defined by (2.4). (Use the definition of CS in
Table 2.1.)</p>
</blockquote>

<p>As a refresher:</p>

<ul>
<li><code>$\text{SmUni}\overset{\text{def}}{=}(\text{CM}|\text{CS})\backslash \text{coin} \backslash \text{coffee}$</code></li>
<li><code>$\text{CM}\overset{\text{def}}{=}\text{coin}.\overline{\text{coffee}}.\text{CM}$</code></li>
<li><code>$\text{CS}\overset{\text{def}}{=}\overline{\text{pub}}.\overline{\text{coin}}.\text{coffee}.\text{CS}$</code></li>
</ul>
</html>
