
<title>niplav</title>
<link rel="shortcut icon" type="image/png" href="./favicon.png">
<link rel="stylesheet" type="text/css" href="main.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!DOCTYPE HTML>

<style TYPE="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>

<script type="text/javascript" async
	src="./mathjax/latest.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
	extensions: ["tex2jax.js"],
	jax: ["input/TeX", "output/HTML-CSS"],
	tex2jax: {
		inlineMath: [ ['$','$'], ["\\(","\\)"] ],
		displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
		processEscapes: true,
		skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
	},
	"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>

<script>
var anchorhash={}
function addAnchor(element) {
	var cnt=element.textContent
	if(cnt==="home")
		return;
	var ref=element.textContent.replace(/[^a-zA-Z0-9 ]/mg, "")
	ref=ref.replace(/ /mg, "-")
	var newref=ref;
	if(anchorhash[ref]===1)
		for(i=1, newref=ref+"_"+i;anchorhash[ref+"_"+i]===1;i++, newref=ref+"_"+i)
			;
	ref=newref
	element.setAttribute("id", `${ref}`)
	element.innerHTML=`<a href="#${ref}" class="hanchor">${cnt}</a>`
	anchorhash[ref]=1
}
document.addEventListener('DOMContentLoaded', function () {
	// Add anchor links to all headings
	var headers = document.querySelectorAll('h1, h2, h3, h4, h5, h6')
	if (headers) {
		headers.forEach(addAnchor)
	}
	// Change the title to the h1 header
	var title = document.querySelector('h1')
	if(title) {
		var title_elem = document.querySelector('title')
		title_elem.textContent=title.textContent + " – niplav"
	}
});
</script>

<h2><a href="./index.html">home</a></h2>

<p><em>author: niplav, created: 2021-10-14, modified: 2021-11-25, language: english, status: in progress, importance: 2, confidence: likely</em></p>

<blockquote>
  <p><strong>This page contains some solutions to exercises from the textbook
“Reactive Systems” by Ingólfsdóttir et al. 2007.</strong></p>
</blockquote>

<h1>Solutions to “Reactive Systems”</h1>

<h2>Chapter 2</h2>

<h3>2.1</h3>

<blockquote>
  <p>Give a CCS process which describes a clock that ticks at least once
and may stop ticking after each clock tick.</p>
</blockquote>

<p><code>$\text{Clock} \overset{\text{def}}{=} (\text{tick}.\mathbf{0}+\text{tick}.\text{Clock})$</code></p>

<h3>2.2</h3>

<blockquote>
  <p>Give a CCS process which describes a coffee machine that may behave
like that given by (2.1) but may also steal the money it receives and
fail at any time.</p>
</blockquote>

<p>This exercise is not quite well-defined. Should it sometimes take the
money and offer nothing in return, but continue functioning, or should
it actually fail sometimes and break down? The former case would be
described by</p>

<p><code>$\text{CTM} \overset{\text{def}}{=} \text{coin}.(\text{CTM}+\overline{\text{coffee}}.\text{CTM}+\overline{\text{tea}}.\text{CTM})$</code>,</p>

<p>the latter by</p>

<p><code>$\text{CTM} \overset{\text{def}}{=} \text{coin}.(\text{CTM}+\mathbf{0}+\overline{\text{coffee}}.\text{CTM}+\overline{\text{tea}}.\text{CTM})$</code></p>

<p>Hey look! <code>$+$</code> is commutative here!</p>

<h3>2.3</h3>

<blockquote>
  <p>A finite process graph <code>$T$</code> is a quadruple <code>$(\mathcal{Q}, A, \delta, q_0)$</code>, where <br />
• <code>$\mathcal{Q}$</code> is a finite set of states, <br />
• <code>$A$</code> is a finite set of labels, <br />
• <code>$q_0 \in \mathcal{Q}$</code> is the start state, and <br />
• <code>$\delta: \mathcal{Q} \times A \rightarrow 2^{\mathcal{Q}}$</code> is the transition function.  </p>

<p>Using the operators introduced so far, give a CCS process that describes <code>$T$</code>.</p>
</blockquote>

<div>
    $$ T=q_0.\underset{a_1 \in A}{\mathbf{+}} (a_1. \underset{q_1 \in δ(q_0, a_1)}{\mathbf{+}} (q_1.\underset{a_2 \in A}{\mathbf{+}} (a_2. \underset{q_2 \in δ(q_1, a_2)}{\mathbf{+}} (q_2. \cdots))))$$
</div>

<p>where <code>$\mathbf{+}$</code> is <em>supposed</em> to be a big iterative operator like
<code>$\sum$</code>, if only I could get MathJax to accept <code>\scalerel</code>. The equation
is nested infinitely deep at most places that result in a loop that
doesn't include <code>$q_0$</code>, and in some places end with <code>$.T$</code>, if <code>$q_0
\in δ(q_n,a)$</code>.</p>

<h3>2.4</h3>

<blockquote>
  <p>Consider the following LTS:</p>
</blockquote>

<p><img src="./img/rs_solutions/diagram_2_4.png" alt="A cyclic diagram for exercise 2.4, described further below." title="A cyclic diagram for exercise 2.4, described further below." /></p>

<blockquote>
  <p>Define the LTS as a triple
<code>$(\text{Proc}, \text{Act}, \{\overset{α}{\rightarrow}|α \in \text{Act}\})$</code>.
Use sketches to illustrate the reflexive closure, symmetric closure and
transitive closure of the binary relation <code>$\overset{α}{\rightarrow}$</code>?</p>
</blockquote>

<p>The process, in triple form, is
<code>$(\{s, s_1, s_2, s_3\}, \{a\}, \overset{a}{\rightarrow}=\{(s, s_1), (s_1, s_2), (s_2, s_3), (s_3, s)\})$</code>.</p>

<p>I'm not sure about the sketch part, but I can try to describe the
different closures.</p>

<p>The reflexive closure of <code>$\overset{a}{\rightarrow}$</code> would additionally
contain the elements
<code>$\{(s,s), (s_1, s_1), (s_2, s_2), (s_3, s_3)\}$</code>.</p>

<p>The symmetric closure is similarly easy to generate: it additionally
contains the elements <code>$\{(s_1, s), (s_2, s_1), (s_3, s_2), (s, s_3)\}$</code>.</p>

<p>The transitive closure additionally contains the elements from the set
<code>$\{(s, s_2), (s, s_3), (s_1, s_3), (s_1, s), (s_2, s), (s_2, s_1), (s_3, s_1), (s_3, s_2)\}$</code>.</p>

<h3>2.5</h3>

<p>The set of reachable states includes all states: <code>$p, p_1$</code> and <code>$p_2$</code>.</p>

<h3>2.6</h3>

<ul>
<li><code>$a.b.A+B$</code> ✓</li>
<li><code>$(a.\mathbf{0}.\overline{a}.A)\backslash \{a,b\}$</code> ✓</li>
<li><code>$(a.\mathbf{0}|\overline{a}.A)\backslash \{a,τ\}$</code> ✗: <code>$τ$</code> can't be excluded</li>
<li><code>$a.B+[a/b]$</code> ✗: a renaming is not a process</li>
<li><code>$τ.τ.B+\mathbf{0}$</code> ✓</li>
<li><code>$(a.B+b.B)[a/b, b/a]$</code> ✓</li>
<li><code>$(a.B+τ.B)[a/τ, b/a]$</code> ✓</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0})|B$</code> ✓</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0}).B$</code> ✗: the object in the parentheses is not a label, but a process</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0})+B$</code> ✓</li>
<li><code>$(\mathbf{0}|\mathbf{0})+\mathbf{0}$</code> ✓</li>
</ul>

<!--
### 2.7

> Use the rules of SOS semantics for CCS to derive the LTS for the
process `$\text{SmUni}$` defined by (2.4). (Use the definition of CS in
Table 2.1.)

As a refresher:

* `$\text{SmUni}\overset{\text{def}}{=}(\text{CM}|\text{CS})\backslash \text{coin} \backslash \text{coffee}$`
* `$\text{CM}\overset{\text{def}}{=}\text{coin}.\overline{\text{coffee}}.\text{CM}$`
* `$\text{CS}\overset{\text{def}}{=}\overline{\text{pub}}.\overline{\text{coin}}.\text{coffee}.\text{CS}$`

TODO
-->

<h3>2.12</h3>

<h2>Chapter 3</h2>

<h3>3.1</h3>

<p>Identity relation is an equivalence relation, as well as the universal
relation is.  The standard <code>$\le$</code> relation is not an equivalence relation
(but it is a preorder, since it is an order). However, the parity relation
<code>$M_2$</code> is.</p>

<h3>Stray Exercise 1</h3>

<blockquote>
  <p>To answer these questions, consider the coffee and tea machine CTM
defined in (2.2) and compare it with the following machine:</p>
</blockquote>

<div>
    $$\text{CTM}'\overset{\text{def}}{=} \text{coin}.\overline{\text{coffee}}.\text{CTM}' + \text{coin}.\overline{\text{tea}}$$
</div>

<blockquote>
  <p>You should be able to convince yourself that CTM and CTM' afford the
same traces. (Do so!)</p>
</blockquote>

<p>It suffices to show that traces of one recursive iteration of CTM and CTM'
are equivalent. The trace of CTM' is
<code>$\{(\text{coin}, \overline{\text{coffee}}),(\text{coin}, \overline{\text{tea}})\}$</code>
(choose at the beginning, then insert coin &amp; get beverage), the trace
of CTM is
<code>$\{(\text{coin}, \overline{\text{coffee}}), (\text{coin}, \overline{\text{tea}})\}$</code>
(insert coin, then choose).</p>

<h3>3.2</h3>

<blockquote>
  <p>1. Do the processes (CA|CTM)\{coin, coffee, tea} and (CA|CTM')\{coin,
coffee, tea} defined above have the same completed traces?</p>
</blockquote>

<p>Yes. Both processes start able to making the coin transition. Then
(CA|CTM') either finds itself in the coffee arm, makes the coffee
transition and returns to the starting state, or gets stuck only emitting
tea, but only accepting coffee. (CA|CTM) decides after the first coin
transition; if CTM transitions into the tea arm, we have a deadlock,
but if it transitions into the coffee arm, it can transition and returns
to the starting state.</p>

<p>For them to have different traces, CTM in (CA|CTM) would need to decide
which arm to transition into by knowing which transitions are available
in CA, which isn't included in the formalism.</p>

<p>Both processes have traces that can be described by the regular expression
<code>coin(,coffee,coin)*</code></p>

<blockquote>
  <p>2. Is it true that if P and Q are two CCS processes affording the
same completed traces and L is a set of labels then P\L and Q\L also
have the same completed traces?</p>
</blockquote>

<p>Yes. The restriction operator \ only restricts transitions outside of
the process it applies to, inside that process the same transitions can
still occur.</p>

<h3>3.3</h3>

<p>The strong bisimulation of <code>$P$</code> and <code>$Q$</code> is
<code>${\mathcal{R}}=\{(P,Q),(P,Q_2),(P_1,Q_1),(P_1,Q_3)\}$</code>.</p>

<p>To show that this relation is a bisimulation, we examine all steps in
the model:</p>

<p>For <code>$(P,Q)$</code>: <code>$P$</code> transitions to <code>$P_1$</code> via <code>$a$</code>, and <code>$Q$</code>
transitions to <code>$Q_1$</code> via <code>$a$</code>, with <code>$(P_1, Q_1)$</code> in <code>$\mathcal{R}$</code>. <br />
<code>$Q$</code> transitions to <code>$Q_1$</code> via <code>$a$</code>, and <code>$P$</code> transitions to <code>$P_1$</code>
via <code>$a$</code>, with the same relation as above.</p>

<p>For <code>$(P,Q_2)$</code>: <code>$P$</code> transitions to <code>$P_1$</code> via <code>$a$</code>, and <code>$Q_2$</code>
transitions to <code>$Q_3$</code> via <code>$a$</code>, with <code>$(P_1, Q_3)$</code> in <code>$\mathcal{R}$</code>.
<code>$Q_2$</code> transitions to <code>$Q_3$</code> via <code>$a$</code>, and <code>$P$</code> transitions to <code>$P_1$</code>
via <code>$a$</code>, with the same relation as above.</p>

<p>For <code>$(P_1,Q_1)$</code>: <code>$P_1$</code> transitions to <code>$P$</code> via <code>$b$</code>, and <code>$Q_1$</code>
transitions to <code>$Q$</code> via <code>$c$</code>, with <code>$(P, Q)$</code> in <code>$\mathcal{R}$</code>
(the same holds for the transition action <code>$b$</code> instead of <code>$c$</code> and
<code>$Q_2$</code> instead of <code>$Q$</code>).
<code>$Q_1$</code> transitions to <code>$Q$</code> via <code>$b$</code>, and <code>$P_1$</code> transitions to <code>$P$</code>
via <code>$b$</code>, with the same relation as above (and, similarly, also with
<code>$c$</code> and <code>$Q_2$</code>).</p>

<p>For <code>$(P_1,Q_3)$</code>: <code>$P_1$</code> transitions to <code>$P$</code> via <code>$b$</code>, and <code>$Q_3$</code>
transitions to <code>$Q$</code> via <code>$b$</code>, with <code>$(P, Q)$</code> in <code>$\mathcal{R}$</code>
(the same holds for the transition action <code>$c$</code> instead of <code>$b$</code> and
<code>$Q_2$</code> instead of <code>$Q_3$</code>).
<code>$Q_3$</code> transitions to <code>$Q$</code> via <code>$b$</code>, and <code>$P_1$</code> transitions to <code>$P$</code>
via <code>$b$</code>, with the same relation as above (and, similarly, also with
<code>$c$</code> and <code>$Q_2$</code> instead of <code>$Q$</code>).</p>

<h3>3.9</h3>

<p>This screams after a proof by induction.</p>

<p>Induction basis: If <code>$σ$</code> is a label, that is, if there exists an action
<code>$α=σ$</code>, then the definitions for strong bisimulation and string
bisimulation coincide (I'm not gonna write it all out, sorry).</p>

<p>Induction assumption: Assume that if <code>$σ$</code> is a sequence of actions, then
two states <code>$s$</code> and <code>$s'$</code> are string bisimilar off they are strongly
bisimilar.</p>

<p>Induction step:</p>

<p>String bisimilarity <code>$\Rightarrow$</code> strong bisimilarity:</p>

<p>If we know that <code>$s_1 \mathcal{R} s_2$</code> are string bisimilar
by a transition <code>$σα$</code>, where <code>$α$</code> is a single action. Then there must be
some <code>$s_1'', s_2''$</code> so that <code>$s_1 \overset{σα}{\rightarrow} s_1''$</code>
and <code>$s_2 \overset{σα}{\rightarrow} s_2''$</code> and <code>$s_1'' \mathcal{R} s_2''$</code>,
and there must be some
<code>$s_1'$</code>, <code>$s_2'$</code> so that <code>$s_1 \overset{σ}{\rightarrow} s_1'$</code> and
<code>$s_2 \overset{σ}{\rightarrow} s_2'$</code> with <code>$s_1' \mathcal{R} s_2'$</code>
(and the other way around, with <code>$s_1$</code> and <code>$s_2$</code> exchanged), where
<code>$s_1'$</code> transitions to <code>$s_1''$</code> via <code>$α$</code>. Then the induction
assumption holds, and we know that the states are also strongly bisimilar.</p>

<p>Strong bisimilarity <code>$\Rightarrow$</code> string bisimilarity:</p>

<p>This is equivalent to the induction basis: if <code>$s_1 \mathcal{R} s_2$</code>
strongly bisimilar via <code>$β$</code>, then they are also string bisimilar via
<code>$σ=β$</code>.</p>

<h3>3.12</h3>

<!--TODO-->

<h3>3.37</h3>

<p><code>$s \not \sim t$</code>. Winning strategy for the attacker:</p>

<ul>
<li><code>$t \overset{a}{\rightarrow} t_1$</code>, defender answers with <code>$s \overset{a}{\rightarrow} s_1$</code></li>
<li><code>$t_1 \overset{b}{\rightarrow} t_2$</code>, defender answers with <code>$s_1 \overset{b}{\rightarrow} s_2$</code></li>
<li><code>$s_2 \overset{b}{\rightarrow} s_2$</code>, defender can't transition anywhere using <code>$b$</code></li>
</ul>

<p><code>$s \sim u$</code>. Winning strategy for the defender:</p>

<ul>
<li>In <code>$(s, u)$</code>
<ul>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} s_1$</code>, play <code>$\overset{a}{\rightarrow} u_1$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} u_1$</code>, play <code>$\overset{a}{\rightarrow} s_1$</code></li>
</ul></li>
<li>In <code>$(s_1, u_1)$</code>
<ul>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} s_2$</code>, play <code>$\overset{b}{\rightarrow} u_3$</code></li>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} u_3$</code>, play <code>$\overset{b}{\rightarrow} s_2$</code></li>
</ul></li>
<li>In <code>$(s_2, u_3)$</code>
<ul>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} s_2$</code>, play <code>$\overset{b}{\rightarrow} u_2$</code></li>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} u_2$</code>, play <code>$\overset{b}{\rightarrow} s_2$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} s$</code>, play <code>$\overset{a}{\rightarrow} u$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} u$</code>, play <code>$\overset{a}{\rightarrow} s$</code></li>
</ul></li>
<li>In <code>$(s_2, u_2)$</code>
<ul>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} s_2$</code>, play <code>$\overset{b}{\rightarrow} u_2$</code></li>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} u_2$</code>, play <code>$\overset{b}{\rightarrow} s_2$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} s$</code>, play <code>$\overset{a}{\rightarrow} u$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} u$</code>, play <code>$\overset{a}{\rightarrow} s$</code></li>
</ul></li>
</ul>

<p>Strong bisimulation relating the pair of processes:
<code>$\mathcal{R}=\{(u,s), (u_1, s_1), (u_3, s_2), (u_2, s_2)\}$</code>.</p>

<p><code>$s\not \sim v$</code>. Winning strategy for the attacker:</p>

<ul>
<li><code>$s \overset{a}{\rightarrow} s_1$</code>, defender answers with <code>$v \overset{a}{\rightarrow} v_1$</code></li>
<li><code>$s_1 \overset{b}{\rightarrow} s_2$</code>
<ul>
<li>defender answers with <code>$v_1 \overset{b}{\rightarrow} v_2$</code>
<ul>
<li><code>$s_2 \overset{b}{\rightarrow} s_2$</code></li>
<li>defender can't transition using <code>$b$</code> from <code>$v_2$</code></li>
</ul></li>
<li>defender answers with <code>$v_1 \overset{b}{\rightarrow} v_3$</code>
<ul>
<li><code>$s_2 \overset{a}{\rightarrow} s$</code></li>
<li>defender can't transition using <code>$a$</code> from <code>$v_3$</code></li>
</ul></li>
</ul></li>
</ul>

<!--
### 3.41
TODO
-->

<h3>Stray Exercise 2</h3>

<blockquote>
  <p>For example, you should be able to convince yourself
that the LTS associated with the CCS expression
<code>$a_1.\mathbf{0}|a_2.\mathbf{0}|\dots|a_n.\mathbf{0}$</code> has <code>$2^n$</code> states.</p>
</blockquote>

<p>Actually, I don't have a good idea of how to put this into LTS form?
I would have to invent a starting state <code>$s_0$</code>, or maybe a set of
<code>$n$</code> starting states, or perhaps <code>$2^n$</code> starting states? Then those
would transition to <code>$\mathbf{0}$</code> via any subset of
<code>$\{a_1, a_2, \dots, a_n\}$</code>.</p>

<p>I should clarify how this is done.</p>

<h2>Chapter 4</h2>

<h3>4.1</h3>

<p>Show that the set of strings <code>$A^*$</code> over an alphabet <code>$A$</code> with prefix
ordering <code>$\le$</code> is a poset (prefix ordering is for all <code>$s, t \in A^*: s \le t$</code>
iff there exists a <code>$w \in A^*$</code> so that <code>$sw=t$</code>).</p>

<ul>
<li>Reflexive: Yes, <code>$s$</code> is a prefix for <code>$s$</code> with <code>$w=ε$</code>.</li>
<li>Antisymmetric: Yes, if <code>$sw=t$</code> and <code>$tw=s$</code>, then <code>$sw=tw$</code>, so <code>$s=t$</code> and <code>$w=ε$</code>.</li>
<li>Transitive: Yes, if <code>$r$</code> is a prefix for <code>$s$</code> with <code>$v$</code> and <code>$s$</code> is a prefix for <code>$t$</code> with <code>$w$</code>, then <code>$r$</code> is a prefix for <code>$t$</code> with <code>$vw$</code>.</li>
</ul>

<!--TODO: finish with other examples?-->

<h3>4.2</h3>

<blockquote>
  <p>Is the poset <code>$(2^S, \subseteq)$</code> totally ordered?</p>
</blockquote>

<p>No: Let <code>$S=\{a,b,c\}$</code>, then it is the case that
<code>$\{a,b\} \not \subseteq \{b,c\}$</code> and <code>$\{b,c\} \not \subseteq \{a,b\}$</code>.</p>

<h3>4.3</h3>

<blockquote>
  <p>Prove that the lub and the glb of <code>$X$</code> are unique, if they exist.</p>
</blockquote>

<p><code>$d$</code> must be an upper bound for <code>$X$</code>, and <code>$d \sqsubseteq d'$</code> for every
upper bound <code>$d' \in D$</code> of <code>$X$</code>. Per antisymmetry of <code>$\sqsubseteq$</code>,
there can be no <code>$d'$</code> so that <code>$d' \sqsubseteq d$</code> and <code>$d \sqsubseteq
d'$</code> with <code>$d' \not = d$</code>. And for <code>$d$</code> to be an upper bound, then it
must be comparable to every other upper bound of <code>$X$</code>, so there is no
uncomparable least other upper bound <code>$d'$</code>.</p>

<p>The same argument applies symmetrically to the greatest lower bound,
and is not worth elaborating.</p>

<!--
### Stray Exercise 3

p. 99, prove snd part of Tarski's fixed point theorem.

TODO
-->

<h3>4.9</h3>

<p>Least fixed point:</p>

<p>Start with <code>$d=\emptyset$</code>. Then <code>$f^0(d)=\{2\}$</code>, and <code>$f^1(d)=\{2\}$</code>
as well. So <code>$\{2\}$</code> is the least fixed point.</p>

<p>Largest fixed point:</p>

<p>Start with <code>$d=\{0,1,2\}$</code>. Then <code>$f^0(d)=\{1,2\}$</code>, and
<code>$f^1(d)=\{1,2\}$</code>. So <code>$\{1,2\}$</code> is the largest fixed point.</p>

<h3>Stray Exercise 4</h3>

<blockquote>
  <p>We note that if <code>$\mathcal{R}, \mathcal{S} \in 2^{(\text{Proc} \times \text{Proc})}$</code>
and <code>$\mathcal{R} \subseteq \mathcal{S}$</code> then
<code>$\mathcal{F}(\mathcal{R}) \subseteq \mathcal{F}(\mathcal{S})$</code>,
that is, the function <code>$\mathcal{F}$</code> is monotonic over
<code>$(2^{(\text{Proc} \times \text{Proc})}, \subseteq)$</code>.</p>
</blockquote>

<p>Assume that <code>$\mathcal{R} \subseteq \mathcal{S}$</code>, but
<code>$\mathcal{F}(\mathcal{R}) \not \subseteq \mathcal{F}(\mathcal{S})$</code>
(that is, <code>$\mathcal{F}(\mathcal{S}) \subset \mathcal{F}(\mathcal{R})$</code>).</p>

<p>Then there must be a <code>$(p,q) \in \mathcal{F}(\mathcal{R})$</code>
(<code>$p, q \in \text{Proc}$</code>) that is not in <code>$\mathcal{F}(\mathcal{S})$</code>.</p>

<p>Then there are <code>$(p', q') \in \mathcal{R}$</code> so that <code>$p, q$</code> can transition
to <code>$p', q'$</code> via some <code>$α$</code>, and <code>$(p', q') \not \in \mathcal{S}$</code>. But
that can't be the case, since we assumed that <code>$\mathcal{R} \subseteq \mathcal{S}$</code>.
This is a contradiction.</p>
</html>
