
<title>niplav</title>
<link rel="shortcut icon" type="image/png" href="./favicon.png">
<link rel="stylesheet" type="text/css" href="main.css">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!DOCTYPE HTML>

<style TYPE="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>

<script type="text/javascript" async
	src="./mathjax/latest.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
	extensions: ["tex2jax.js"],
	jax: ["input/TeX", "output/HTML-CSS"],
	tex2jax: {
		inlineMath: [ ['$','$'], ["\\(","\\)"] ],
		displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
		processEscapes: true,
		skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
	},
	"HTML-CSS": { availableFonts: ["TeX"] }
	});
</script>

<script>
var anchorhash={}
function addAnchor(element) {
	var cnt=element.textContent
	if(cnt==="home")
		return;
	var ref=element.textContent.replace(/[^a-zA-Z0-9 ]/mg, "")
	ref=ref.replace(/ /mg, "-")
	var newref=ref;
	if(anchorhash[ref]===1)
		for(i=1, newref=ref+"_"+i;anchorhash[ref+"_"+i]===1;i++, newref=ref+"_"+i)
			;
	ref=newref
	element.setAttribute("id", `${ref}`)
	element.innerHTML=`<a href="#${ref}" class="hanchor">${cnt}</a>`
	anchorhash[ref]=1
}
document.addEventListener('DOMContentLoaded', function () {
	// Add anchor links to all headings
	var headers = document.querySelectorAll('h1, h2, h3, h4, h5, h6')
	if (headers) {
		headers.forEach(addAnchor)
	}
	// Change the title to the h1 header
	var title = document.querySelector('h1')
	if(title) {
		var title_elem = document.querySelector('title')
		title_elem.textContent=title.textContent + " – niplav"
	}
});
</script>

<h2><a href="./index.html">home</a></h2>

<p><em>author: niplav, created: 2021-10-14, modified: 2022-01-15, language: english, status: in progress, importance: 2, confidence: likely</em></p>

<blockquote>
  <p><strong>This page contains some solutions to exercises from the textbook
“Reactive Systems” by Ingólfsdóttir et al. 2007.</strong></p>
</blockquote>

<h1>Solutions to “Reactive Systems”</h1>

<h2>Chapter 2</h2>

<h3>2.1</h3>

<blockquote>
  <p>Give a CCS process which describes a clock that ticks at least once
and may stop ticking after each clock tick.</p>
</blockquote>

<p><code>$\text{Clock} \overset{\text{def}}{=} (\text{tick}.\mathbf{0}+\text{tick}.\text{Clock})$</code></p>

<h3>2.2</h3>

<blockquote>
  <p>Give a CCS process which describes a coffee machine that may behave
like that given by (2.1) but may also steal the money it receives and
fail at any time.</p>
</blockquote>

<p>This exercise is not quite well-defined. Should it sometimes take the
money and offer nothing in return, but continue functioning, or should
it actually fail sometimes and break down? The former case would be
described by</p>

<p><code>$\text{CTM} \overset{\text{def}}{=} \text{coin}.(\text{CTM}+\overline{\text{coffee}}.\text{CTM}+\overline{\text{tea}}.\text{CTM})$</code>,</p>

<p>the latter by</p>

<p><code>$\text{CTM} \overset{\text{def}}{=} \text{coin}.(\text{CTM}+\mathbf{0}+\overline{\text{coffee}}.\text{CTM}+\overline{\text{tea}}.\text{CTM})$</code></p>

<p>Hey look! <code>$+$</code> is commutative here!</p>

<h3>2.3</h3>

<blockquote>
  <p>A finite process graph <code>$T$</code> is a quadruple <code>$(\mathcal{Q}, A, \delta, q_0)$</code>, where <br />
• <code>$\mathcal{Q}$</code> is a finite set of states, <br />
• <code>$A$</code> is a finite set of labels, <br />
• <code>$q_0 \in \mathcal{Q}$</code> is the start state, and <br />
• <code>$\delta: \mathcal{Q} \times A \rightarrow 2^{\mathcal{Q}}$</code> is the transition function.  </p>

<p>Using the operators introduced so far, give a CCS process that describes <code>$T$</code>.</p>
</blockquote>

<div>
    $$ T=q_0.\underset{a_1 \in A}{\mathbf{+}} (a_1. \underset{q_1 \in δ(q_0, a_1)}{\mathbf{+}} (q_1.\underset{a_2 \in A}{\mathbf{+}} (a_2. \underset{q_2 \in δ(q_1, a_2)}{\mathbf{+}} (q_2. \cdots))))$$
</div>

<p>where <code>$\mathbf{+}$</code> is <em>supposed</em> to be a big iterative operator like
<code>$\sum$</code>, if only I could get MathJax to accept <code>\scalerel</code>. The equation
is nested infinitely deep at most places that result in a loop that
doesn't include <code>$q_0$</code>, and in some places end with <code>$.T$</code>, if <code>$q_0
\in δ(q_n,a)$</code>.</p>

<h3>2.4</h3>

<blockquote>
  <p>Consider the following LTS:</p>
</blockquote>

<p><img src="./img/rs_solutions/diagram_2_4.png" alt="A cyclic diagram for exercise 2.4, described further below." title="A cyclic diagram for exercise 2.4, described further below." /></p>

<blockquote>
  <p>Define the LTS as a triple
<code>$(\textbf{Proc}, \text{Act}, \{\overset{α}{\rightarrow}|α \in \text{Act}\})$</code>.
Use sketches to illustrate the reflexive closure, symmetric closure and
transitive closure of the binary relation <code>$\overset{α}{\rightarrow}$</code>?</p>
</blockquote>

<p>The process, in triple form, is
<code>$(\{s, s_1, s_2, s_3\}, \{a\}, \overset{a}{\rightarrow}=\{(s, s_1), (s_1, s_2), (s_2, s_3), (s_3, s)\})$</code>.</p>

<p>I'm not sure about the sketch part, but I can try to describe the
different closures.</p>

<p>The reflexive closure of <code>$\overset{a}{\rightarrow}$</code> would additionally
contain the elements
<code>$\{(s,s), (s_1, s_1), (s_2, s_2), (s_3, s_3)\}$</code>.</p>

<p>The symmetric closure is similarly easy to generate: it additionally
contains the elements <code>$\{(s_1, s), (s_2, s_1), (s_3, s_2), (s, s_3)\}$</code>.</p>

<p>The transitive closure additionally contains the elements from the set
<code>$\{(s, s_2), (s, s_3), (s_1, s_3), (s_1, s), (s_2, s), (s_2, s_1), (s_3, s_1), (s_3, s_2)\}$</code>.</p>

<h3>2.5</h3>

<p>The set of reachable states includes all states: <code>$p, p_1$</code> and <code>$p_2$</code>.</p>

<h3>2.6</h3>

<ul>
<li><code>$a.b.A+B$</code> ✓</li>
<li><code>$(a.\mathbf{0}.\overline{a}.A)\backslash \{a,b\}$</code> ✓</li>
<li><code>$(a.\mathbf{0}|\overline{a}.A)\backslash \{a,τ\}$</code> ✗: <code>$τ$</code> can't be excluded</li>
<li><code>$a.B+[a/b]$</code> ✗: a renaming is not a process</li>
<li><code>$τ.τ.B+\mathbf{0}$</code> ✓</li>
<li><code>$(a.B+b.B)[a/b, b/a]$</code> ✓</li>
<li><code>$(a.B+τ.B)[a/τ, b/a]$</code> ✓</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0})|B$</code> ✓</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0}).B$</code> ✗: the object in the parentheses is not a label, but a process</li>
<li><code>$(a.b.A+\overline{a}.\mathbf{0})+B$</code> ✓</li>
<li><code>$(\mathbf{0}|\mathbf{0})+\mathbf{0}$</code> ✓</li>
</ul>

<h3>2.7</h3>

<blockquote>
  <p>Use the rules of SOS semantics for CCS to derive the LTS for the
process <code>$\text{SmUni}$</code> defined by (2.4). (Use the definition of CS in
Table 2.1.)</p>
</blockquote>

<p>As a refresher:</p>

<ul>
<li><code>$\text{SmUni}\overset{\text{def}}{=}(\text{CM}|\text{CS})\backslash \text{coin} \backslash \text{coffee}$</code></li>
<li><code>$\text{CM}\overset{\text{def}}{=}\text{coin}.\overline{\text{coffee}}.\text{CM}$</code></li>
<li><code>$\text{CS}\overset{\text{def}}{=}\overline{\text{pub}}.\overline{\text{coin}}.\text{coffee}.\text{CS}$</code></li>
</ul>

<p>I'm not going to draw all the images, I'm way too lazy for that.</p>

<ul>
<li>Using COM1: SmUni transitions to <code>$(\text{CM}|\text{CS}_1)\backslash\{\text{coin},\text{coffee}\}$</code> via <code>$\overline{\text{pub}}$</code></li>
<li>Using COM3: <code>$(\text{CM}|\text{CS}_1)\backslash\{\text{coin},\text{coffee}\}$</code> transitions to <code>$(\text{CM}_1|\text{CS}_2)\backslash\{\text{coin},\text{coffee}\}$</code> via <code>$τ$</code>, internally <code>$\text{coin}$</code></li>
<li>Using COM3: <code>$(\text{CM}_1|\text{CS}_2)\backslash\{\text{coin},\text{coffee}\}$</code> transitions to SmUni via <code>$τ$</code>, internally <code>$\text{coffee}$</code></li>
</ul>

<h3>2.12</h3>

<h4>Defining a Bag</h4>

<p><code>$\text{Bag} \overset{\text{def}}{=} (\text{Cell}|\text{Cell}).\text{Bag}$</code></p>

<p>This definition works by keeping two Cells running in parallel. If both
cells are emptied, the Bag restarts, otherwise it keeps its state.</p>

<h4>Defining a FIFO queue</h4>

<p>The two-place FIFO queue should have the following traces available
(for different values of <code>$x$</code> and <code>$y$</code>):</p>

<ul>
<li><code>$\text{in}(x) \rightarrow \text{in}(y) \rightarrow \overline{\text{out}}(x) \rightarrow \overline{\text{out}}(y).\text{FIFO}$</code></li>
<li><code>$\text{in}(x) \rightarrow \overline{\text{out}}(x).\text{FIFO}$</code></li>
</ul>

<p>(The case where <code>$x$</code> is input and output, and then <code>$y$</code> is input and
output, is equivalent to the second trace).</p>

<p><code>$\text{FIFO} \overset{\text{def}}{=} (\text{Cell}+(\text{in}(x).\text{in}(y).\text{Cell}(x).\text{Cell}(y)).\text{FIFO}$</code></p>

<p>This is much uglier than I thought it would be. Maybe there's a nicer
version? Just concatenating two cells doesn't work, of course.</p>

<h2>Chapter 3</h2>

<h3>3.1</h3>

<p>Identity relation is an equivalence relation, as well as the universal
relation is.  The standard <code>$\le$</code> relation is not an equivalence relation
(but it is a preorder, since it is an order). However, the parity relation
<code>$M_2$</code> is.</p>

<h3>Stray Exercise 1</h3>

<blockquote>
  <p>To answer these questions, consider the coffee and tea machine CTM
defined in (2.2) and compare it with the following machine:</p>
</blockquote>

<div>
    $$\text{CTM}'\overset{\text{def}}{=} \text{coin}.\overline{\text{coffee}}.\text{CTM}' + \text{coin}.\overline{\text{tea}}$$
</div>

<blockquote>
  <p>You should be able to convince yourself that CTM and CTM' afford the
same traces. (Do so!)</p>
</blockquote>

<p>It suffices to show that traces of one recursive iteration of CTM and CTM'
are equivalent. The trace of CTM' is
<code>$\{(\text{coin}, \overline{\text{coffee}}),(\text{coin}, \overline{\text{tea}})\}$</code>
(choose at the beginning, then insert coin &amp; get beverage), the trace
of CTM is
<code>$\{(\text{coin}, \overline{\text{coffee}}), (\text{coin}, \overline{\text{tea}})\}$</code>
(insert coin, then choose).</p>

<h3>3.2</h3>

<blockquote>
  <p>1. Do the processes (CA|CTM)\{coin, coffee, tea} and (CA|CTM')\{coin,
coffee, tea} defined above have the same completed traces?</p>
</blockquote>

<p>Yes. Both processes start able to making the coin transition. Then
(CA|CTM') either finds itself in the coffee arm, makes the coffee
transition and returns to the starting state, or gets stuck only emitting
tea, but only accepting coffee. (CA|CTM) decides after the first coin
transition; if CTM transitions into the tea arm, we have a deadlock,
but if it transitions into the coffee arm, it can transition and returns
to the starting state.</p>

<p>For them to have different traces, CTM in (CA|CTM) would need to decide
which arm to transition into by knowing which transitions are available
in CA, which isn't included in the formalism.</p>

<p>Both processes have traces that can be described by the regular expression
<code>coin(,coffee,coin)*</code></p>

<blockquote>
  <p>2. Is it true that if P and Q are two CCS processes affording the
same completed traces and L is a set of labels then P\L and Q\L also
have the same completed traces?</p>
</blockquote>

<p>Yes. The restriction operator \ only restricts transitions outside of
the process it applies to, inside that process the same transitions can
still occur.</p>

<h3>3.3</h3>

<p>The strong bisimulation of <code>$P$</code> and <code>$Q$</code> is
<code>${\mathcal{R}}=\{(P,Q),(P,Q_2),(P_1,Q_1),(P_1,Q_3)\}$</code>.</p>

<p>To show that this relation is a bisimulation, we examine all steps in
the model:</p>

<p>For <code>$(P,Q)$</code>: <code>$P$</code> transitions to <code>$P_1$</code> via <code>$a$</code>, and <code>$Q$</code>
transitions to <code>$Q_1$</code> via <code>$a$</code>, with <code>$(P_1, Q_1)$</code> in <code>$\mathcal{R}$</code>. <br />
<code>$Q$</code> transitions to <code>$Q_1$</code> via <code>$a$</code>, and <code>$P$</code> transitions to <code>$P_1$</code>
via <code>$a$</code>, with the same relation as above.</p>

<p>For <code>$(P,Q_2)$</code>: <code>$P$</code> transitions to <code>$P_1$</code> via <code>$a$</code>, and <code>$Q_2$</code>
transitions to <code>$Q_3$</code> via <code>$a$</code>, with <code>$(P_1, Q_3)$</code> in <code>$\mathcal{R}$</code>.
<code>$Q_2$</code> transitions to <code>$Q_3$</code> via <code>$a$</code>, and <code>$P$</code> transitions to <code>$P_1$</code>
via <code>$a$</code>, with the same relation as above.</p>

<p>For <code>$(P_1,Q_1)$</code>: <code>$P_1$</code> transitions to <code>$P$</code> via <code>$b$</code>, and <code>$Q_1$</code>
transitions to <code>$Q$</code> via <code>$c$</code>, with <code>$(P, Q)$</code> in <code>$\mathcal{R}$</code>
(the same holds for the transition action <code>$b$</code> instead of <code>$c$</code> and
<code>$Q_2$</code> instead of <code>$Q$</code>).
<code>$Q_1$</code> transitions to <code>$Q$</code> via <code>$b$</code>, and <code>$P_1$</code> transitions to <code>$P$</code>
via <code>$b$</code>, with the same relation as above (and, similarly, also with
<code>$c$</code> and <code>$Q_2$</code>).</p>

<p>For <code>$(P_1,Q_3)$</code>: <code>$P_1$</code> transitions to <code>$P$</code> via <code>$b$</code>, and <code>$Q_3$</code>
transitions to <code>$Q$</code> via <code>$b$</code>, with <code>$(P, Q)$</code> in <code>$\mathcal{R}$</code>
(the same holds for the transition action <code>$c$</code> instead of <code>$b$</code> and
<code>$Q_2$</code> instead of <code>$Q_3$</code>).
<code>$Q_3$</code> transitions to <code>$Q$</code> via <code>$b$</code>, and <code>$P_1$</code> transitions to <code>$P$</code>
via <code>$b$</code>, with the same relation as above (and, similarly, also with
<code>$c$</code> and <code>$Q_2$</code> instead of <code>$Q$</code>).</p>

<h3>3.9</h3>

<p>This screams after a proof by induction.</p>

<p>Induction basis: If <code>$σ$</code> is a label, that is, if there exists an action
<code>$α=σ$</code>, then the definitions for strong bisimulation and string
bisimulation coincide (I'm not gonna write it all out, sorry).</p>

<p>Induction assumption: Assume that if <code>$σ$</code> is a sequence of actions, then
two states <code>$s$</code> and <code>$s'$</code> are string bisimilar off they are strongly
bisimilar.</p>

<p>Induction step:</p>

<p>String bisimilarity <code>$\Rightarrow$</code> strong bisimilarity:</p>

<p>If we know that <code>$s_1 \mathcal{R} s_2$</code> are string bisimilar
by a transition <code>$σα$</code>, where <code>$α$</code> is a single action. Then there must be
some <code>$s_1'', s_2''$</code> so that <code>$s_1 \overset{σα}{\rightarrow} s_1''$</code>
and <code>$s_2 \overset{σα}{\rightarrow} s_2''$</code> and <code>$s_1'' \mathcal{R} s_2''$</code>,
and there must be some
<code>$s_1'$</code>, <code>$s_2'$</code> so that <code>$s_1 \overset{σ}{\rightarrow} s_1'$</code> and
<code>$s_2 \overset{σ}{\rightarrow} s_2'$</code> with <code>$s_1' \mathcal{R} s_2'$</code>
(and the other way around, with <code>$s_1$</code> and <code>$s_2$</code> exchanged), where
<code>$s_1'$</code> transitions to <code>$s_1''$</code> via <code>$α$</code>. Then the induction
assumption holds, and we know that the states are also strongly bisimilar.</p>

<p>Strong bisimilarity <code>$\Rightarrow$</code> string bisimilarity:</p>

<p>This is equivalent to the induction basis: if <code>$s_1 \mathcal{R} s_2$</code>
strongly bisimilar via <code>$β$</code>, then they are also string bisimilar via
<code>$σ=β$</code>.</p>

<h3>3.12</h3>

<p>To be shown: <code>$\{(P|Q, Q|P) |\text{where }P,Q \text{ are CCS processes}\}$</code>
is a strong bisimulation.</p>

<p>I am slightly confused: doesn't strong bisimilarity apply to <em>states</em>,
and aren't <code>$P|Q$</code> and <code>$Q|P$</code> processes?</p>

<p>If there is no <code>$α$</code> so that either <code>$P$</code> or <code>$Q$</code> can transition to
another state, <code>$P|Q$</code> and <code>$Q|P$</code> are strongly bisimilar.</p>

<p>If <code>$P|Q \overset{α}{\rightarrow} P'|Q$</code>, then <code>$Q|P \overset{α}{\rightarrow} Q|P'$</code>
by first applying COM1 and then COM2, and so <code>$P'|Q$</code> and <code>$Q|P'$</code>
are strongly bisimilar.</p>

<p>Another idea: we can prove this by backward induction, e.g. assuming that
there is a final state <code>$P_f|Q_f$</code>, which can't transition further, and
then proving that every <code>$α$</code> transition that lands there is a strong
bisimulation, and induced back as well?</p>

<p>The same holds if <code>$Q$</code> can transition via <code>$α$</code>.</p>

<p>If <code>$(P|Q)\backslash \{α\} \overset{τ}{\rightarrow} P'|Q'$</code>, then
similarly <code>$(Q|P)\backslash \{α\} \overset{τ}{\rightarrow} Q|P$</code>
per COM3, so they're strongly bisimilar.</p>

<p>To be shown: <code>$\{(P|\mathbf{0}, P) |\text{where }P \text{ is a CCS process}\}$</code>
is a strong bisimulation.</p>

<p>Isn't this trivial? If <code>$P \overset{α}{\rightarrow} P'$</code>, then surely
also <code>$P|\mathbf{0} \overset{α}{\rightarrow} P'|\mathbf{0}$</code>, and if
<code>$P|\mathbf{0} \overset{α}{\rightarrow} P'|\mathbf{0}$</code>, then
<code>$P \overset{α}{\rightarrow} P'$</code>. <code>$τ$</code>-transitions are not possible here.</p>

<p>To be shown: <code>$\{((P|Q)|R,P|(Q|R)) |\text{where }P,Q,R \text{ are CCS processes}\}$</code>
is a strong bisimulation.</p>

<p>Assume that <code>$(P|Q)|R$</code> makes an <code>$α$</code> transition. Then:</p>

<ul>
<li>If <code>$(P|Q)$</code> made the transition, then:
<ul>
<li>If <code>$P$</code> made the transition, then on the right side <code>$P$</code> can also make the transition</li>
<li>If <code>$Q$</code> made the transition, then on the right side <code>$(Q|R)$</code> can make the transition (e.g. to <code>$(Q'|R)$</code>)</li>
</ul></li>
<li>If <code>$R$</code> made the transition, then on the right side <code>$(Q|R)$</code> can make the transition (e.g. to <code>$(Q|R')$</code>)</li>
</ul>

<p>Otherwise asume that <code>$(P|Q)|R \overset{τ}{\rightarrow} (P|Q')|R'$</code>. Then
there must be a <code>$β$</code> so that <code>$Q \overset{β}{\rightarrow} Q'$</code>
and <code>$R \overset{\overline{β}}{\rightarrow} R'$</code> (or <code>$R$</code> outputs
<code>$β$</code> and <code>$Q$</code> inputs <code>$β$</code>, but that's symmetric). Then similarly
<code>$P|(Q|R) \overset{τ}{\rightarrow} P|(Q'|R')$</code> by the same internal
<code>$β$</code> transitions.</p>

<p>All other cases are symmetric, and I won't enumerate them here.</p>

<p>Since these relations are all bisimulations, it is clear that for any
<code>$P,Q,R$</code>, the mentioned combined processes are bisimilar.</p>

<blockquote>
  <p>Find three CCS processes <code>$P,Q,R$</code> such that <code>$(P+Q)|R \not \sim (P|R)+(Q|R)$</code>.</p>
</blockquote>

<p>I haven't been able to solve this completely yet. Let's take something
like <code>$P \overset{\text{def}}{=}a.a.a.a.a$</code>, <code>$Q \overset{\text{def}}{=}a.a.a.a.b$</code>
and <code>$R \overset{\text{def}}{=}a.a.a.a.(a+b)$</code>. Then it <em>could</em> be the
case that in a bisimulation game, the attacker has chosen the <code>$P$</code>
path on the left hand side, while the defender has chosen the <code>$Q$</code>
path on the right hand side. But this is not guaranteed.</p>

<h3>3.30</h3>

<blockquote>
  <p>Show that observational equivalence is the largest symmetric relation
<code>$\mathcal{R}$</code> satisfying that whenever <code>$s_1 \mathcal{R} s_2$</code> then, for
each action <code>$α$</code> (including <code>$τ$</code>), if <code>$s_1 \overset{α}{\Rightarrow}
s_1'$</code> then there is a transition <code>$s_2 \overset{α}{\Rightarrow} s_2'$</code>
such that <code>$s_1' \mathcal{R} s_2'$</code>.</p>
</blockquote>

<p>Assume there is a relation <code>$\mathcal{R}_{\star}$</code> which satisfies the
conditions given for <code>$\mathcal{R}$</code> above. Then there must be two states
<code>$s_{\star}, t_{\star}$</code> so that if
<code>$s_{\star} \overset{α}{\Rightarrow} s_{\star}'$</code>, then there must be
a transition <code>$t_{\star} \overset{α}{\Rightarrow} t_{\star}'$</code> so that
<code>$s_{\star}' \mathcal{R}_{\star} t_{\star}'$</code>. Since
<code>$\mathcal{R}_{\star}$</code> is supposed to be symmetric, the same must hold
for <code>$t_{\star}$</code>: <code>$t_{\star} \overset{α}{\Rightarrow} t_{\star}'$</code>
implies that there is a transition <code>$s_{\star} \overset{α}{\Rightarrow} s_{\star}'$</code>
so that <code>$t_{\star}' \mathcal{R}_{\star} s_{\star}'$</code>.</p>

<p>We now have to determine whether, if we know that <code>$s_{\star} \mathcal{R}_{\star} t_{\star}$</code>,
we also know that <code>$s_{\star} \approx t_{\star}$</code>. Then there are four different
cases:</p>

<ul>
<li>If <code>$s_{\star} \overset{α}{\Rightarrow} s_{\star}'$</code> is realized by <code>$s_{\star} \overset{α}{\rightarrow} s_{\star}'$</code> in the LTS, then this is equivalent to the definition of observational equivalence.</li>
<li>If <code>$s_{\star} \overset{α}{\Rightarrow} s_{\star}'$</code> is realized by <code>$s_{\star} \overset{α}{\rightarrow} s_{\star}'' \overset{τ}{\rightarrow} s_{\star}'$</code> in the LTS, then there must be a <code>$t_{\star}''$</code> so that <code>$s_{\star}'' \mathcal{R}_{\star} t_{\star}''$</code> (per definition in the exercise), so we can take that relation as belonging to <code>$\approx$</code>.</li>
<li>If <code>$s_{\star} \overset{α}{\Rightarrow} s_{\star}'$</code> is realized by <code>$s_{\star} \overset{τ}{\rightarrow} s_{\star}'' \overset{α}{\rightarrow} s_{\star}'$</code> in the LTS, then there must be a <code>$t_{\star}''$</code> so that <code>$s_{\star}'' \mathcal{R}_{\star} t_{\star}''$</code>, only this time via a <code>$τ$</code> transition (i.e. <code>$t_{\star} \overset{τ}{\rightarrow} t_{\star}''$</code>). So we can take that relation as belonging to <code>$\approx$</code>. (This doesn't work! What if <code>$t_{\star} \overset{α}{\Rightarrow} t_{\star}'$</code> is realized by <code>$t_{\star} \overset{α}{\rightarrow} t_{\star}'' \overset{τ}{\rightarrow} t_{\star}'$</code>? Then we can't just take the first part of the transition and declare it to be a <code>$τ$</code> transition. Hmmm.)</li>
<li>If <code>$s_{\star} \overset{α}{\Rightarrow} s_{\star}'$</code> is realized by <code>$s_{\star} \overset{α}{\rightarrow} s_{\star}'' \overset{τ}{\rightarrow} s_{\star}'$</code>, then we can again just chop off the last transition and declare the rest to be the <code>$α$</code> transition, so that now <code>$s_{\star} \approx t_{\star}$</code> and <code>$s_{\star}'' \approx t_{\star}'$</code>.</li>
</ul>

<p>Since every <code>$\rightarrow$</code> transition is also a weak transition,
there can be no observational equivalence that isn't also in
<code>$\mathcal{R}_{\star}$</code>. So <code>$\mathcal{R}_{\star}$</code> is the biggest
observational equivalence <code>$\approx$</code>.</p>

<h3>3.37</h3>

<p><code>$s \not \sim t$</code>. Winning strategy for the attacker:</p>

<ul>
<li><code>$t \overset{a}{\rightarrow} t_1$</code>, defender answers with <code>$s \overset{a}{\rightarrow} s_1$</code></li>
<li><code>$t_1 \overset{b}{\rightarrow} t_2$</code>, defender answers with <code>$s_1 \overset{b}{\rightarrow} s_2$</code></li>
<li><code>$s_2 \overset{b}{\rightarrow} s_2$</code>, defender can't transition anywhere using <code>$b$</code></li>
</ul>

<p><code>$s \sim u$</code>. Winning strategy for the defender:</p>

<ul>
<li>In <code>$(s, u)$</code>
<ul>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} s_1$</code>, play <code>$\overset{a}{\rightarrow} u_1$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} u_1$</code>, play <code>$\overset{a}{\rightarrow} s_1$</code></li>
</ul></li>
<li>In <code>$(s_1, u_1)$</code>
<ul>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} s_2$</code>, play <code>$\overset{b}{\rightarrow} u_3$</code></li>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} u_3$</code>, play <code>$\overset{b}{\rightarrow} s_2$</code></li>
</ul></li>
<li>In <code>$(s_2, u_3)$</code>
<ul>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} s_2$</code>, play <code>$\overset{b}{\rightarrow} u_2$</code></li>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} u_2$</code>, play <code>$\overset{b}{\rightarrow} s_2$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} s$</code>, play <code>$\overset{a}{\rightarrow} u$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} u$</code>, play <code>$\overset{a}{\rightarrow} s$</code></li>
</ul></li>
<li>In <code>$(s_2, u_2)$</code>
<ul>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} s_2$</code>, play <code>$\overset{b}{\rightarrow} u_2$</code></li>
<li>If the attacker plays <code>$\overset{b}{\rightarrow} u_2$</code>, play <code>$\overset{b}{\rightarrow} s_2$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} s$</code>, play <code>$\overset{a}{\rightarrow} u$</code></li>
<li>If the attacker plays <code>$\overset{a}{\rightarrow} u$</code>, play <code>$\overset{a}{\rightarrow} s$</code></li>
</ul></li>
</ul>

<p>Strong bisimulation relating the pair of processes:
<code>$\mathcal{R}=\{(u,s), (u_1, s_1), (u_3, s_2), (u_2, s_2)\}$</code>.</p>

<p><code>$s\not \sim v$</code>. Winning strategy for the attacker:</p>

<ul>
<li><code>$s \overset{a}{\rightarrow} s_1$</code>, defender answers with <code>$v \overset{a}{\rightarrow} v_1$</code></li>
<li><code>$s_1 \overset{b}{\rightarrow} s_2$</code>
<ul>
<li>defender answers with <code>$v_1 \overset{b}{\rightarrow} v_2$</code>
<ul>
<li><code>$s_2 \overset{b}{\rightarrow} s_2$</code></li>
<li>defender can't transition using <code>$b$</code> from <code>$v_2$</code></li>
</ul></li>
<li>defender answers with <code>$v_1 \overset{b}{\rightarrow} v_3$</code>
<ul>
<li><code>$s_2 \overset{a}{\rightarrow} s$</code></li>
<li>defender can't transition using <code>$a$</code> from <code>$v_3$</code></li>
</ul></li>
</ul></li>
</ul>

<h3>3.41</h3>

<p>Assume that there is some <code>$α$</code> that the attacker would be able to play
<code>$s \overset{α}{\Rightarrow} s_3$</code>, but not <code>$s \overset{α}{\rightarrow}
s'$</code>. Then the <code>$\overset{α}{\Rightarrow}$</code> would decompose into
<code>$s \overset{τ}{\rightarrow}^+ s_1 \overset{α}{\rightarrow} s_2 \overset{τ}{\rightarrow}^* s_3$</code>.
So the only additional possible action the attacker could additionally
play would be <code>$τ$</code>. But in this case, the defender can answer by doing
nothing, i.e. idling on the same state (see p. 89). So the additional
<code>$τ$</code> transition doesn't give the attacker any useful moves, and both
versions of the game are equivalent.</p>

<h3>Stray Exercise 2</h3>

<blockquote>
  <p>For example, you should be able to convince yourself
that the LTS associated with the CCS expression
<code>$a_1.\mathbf{0}|a_2.\mathbf{0}|\dots|a_n.\mathbf{0}$</code> has <code>$2^n$</code> states.</p>
</blockquote>

<p>Actually, I don't have a good idea of how to put this into LTS form?
I would have to invent a starting state <code>$s_0$</code>, or maybe a set of
<code>$n$</code> starting states, or perhaps <code>$2^n$</code> starting states? Then those
would transition to <code>$\mathbf{0}$</code> via any subset of
<code>$\{a_1, a_2, \dots, a_n\}$</code>.</p>

<p>I should clarify how this is done.</p>

<h2>Chapter 4</h2>

<h3>4.1</h3>

<p>Show that the set of strings <code>$A^*$</code> over an alphabet <code>$A$</code> with prefix
ordering <code>$\le$</code> is a poset (prefix ordering is for all <code>$s, t \in A^*: s \le t$</code>
iff there exists a <code>$w \in A^*$</code> so that <code>$sw=t$</code>).</p>

<ul>
<li>Reflexive: Yes, <code>$s$</code> is a prefix for <code>$s$</code> with <code>$w=ε$</code>.</li>
<li>Antisymmetric: Yes, if <code>$sw=t$</code> and <code>$tw=s$</code>, then <code>$sw=tw$</code>, so <code>$s=t$</code> and <code>$w=ε$</code>.</li>
<li>Transitive: Yes, if <code>$r$</code> is a prefix for <code>$s$</code> with <code>$v$</code> and <code>$s$</code> is a prefix for <code>$t$</code> with <code>$w$</code>, then <code>$r$</code> is a prefix for <code>$t$</code> with <code>$vw$</code>.</li>
</ul>

<!--TODO: finish with other examples-->

<h3>4.2</h3>

<blockquote>
  <p>Is the poset <code>$(2^S, \subseteq)$</code> totally ordered?</p>
</blockquote>

<p>No: Let <code>$S=\{a,b,c\}$</code>, then it is the case that
<code>$\{a,b\} \not \subseteq \{b,c\}$</code> and <code>$\{b,c\} \not \subseteq \{a,b\}$</code>.</p>

<h3>4.3</h3>

<blockquote>
  <p>Prove that the lub and the glb of <code>$X$</code> are unique, if they exist.</p>
</blockquote>

<p><code>$d$</code> must be an upper bound for <code>$X$</code>, and <code>$d \sqsubseteq d'$</code> for every
upper bound <code>$d' \in D$</code> of <code>$X$</code>. Per antisymmetry of <code>$\sqsubseteq$</code>,
there can be no <code>$d'$</code> so that <code>$d' \sqsubseteq d$</code> and <code>$d \sqsubseteq
d'$</code> with <code>$d' \not = d$</code>. And for <code>$d$</code> to be an upper bound, then it
must be comparable to every other upper bound of <code>$X$</code>, so there is no
uncomparable least other upper bound <code>$d'$</code>.</p>

<p>The same argument applies symmetrically to the greatest lower bound,
and is not worth elaborating.</p>

<!--
### Stray Exercise 3

p. 99, prove snd part of Tarski's fixed point theorem.

TODO
-->

<h3>4.9</h3>

<p>Least fixed point:</p>

<p>Start with <code>$d=\emptyset$</code>. Then <code>$f^0(d)=\{2\}$</code>, and <code>$f^1(d)=\{2\}$</code>
as well. So <code>$\{2\}$</code> is the least fixed point.</p>

<p>Largest fixed point:</p>

<p>Start with <code>$d=\{0,1,2\}$</code>. Then <code>$f^0(d)=\{1,2\}$</code>, and
<code>$f^1(d)=\{1,2\}$</code>. So <code>$\{1,2\}$</code> is the largest fixed point.</p>

<h3>Stray Exercise 4</h3>

<blockquote>
  <p>We note that if <code>$\mathcal{R}, \mathcal{S} \in 2^{(\textbf{Proc} \times \textbf{Proc})}$</code>
and <code>$\mathcal{R} \subseteq \mathcal{S}$</code> then
<code>$\mathcal{F}(\mathcal{R}) \subseteq \mathcal{F}(\mathcal{S})$</code>,
that is, the function <code>$\mathcal{F}$</code> is monotonic over
<code>$(2^{(\textbf{Proc} \times \textbf{Proc})}, \subseteq)$</code>.</p>
</blockquote>

<p>Assume that <code>$\mathcal{R} \subseteq \mathcal{S}$</code>, but
<code>$\mathcal{F}(\mathcal{R}) \not \subseteq \mathcal{F}(\mathcal{S})$</code>
(that is, <code>$\mathcal{F}(\mathcal{S}) \subset \mathcal{F}(\mathcal{R})$</code>).</p>

<p>Then there must be a <code>$(p,q) \in \mathcal{F}(\mathcal{R})$</code>
(<code>$p, q \in \textbf{Proc}$</code>) that is not in <code>$\mathcal{F}(\mathcal{S})$</code>.</p>

<p>Then there are <code>$(p', q') \in \mathcal{R}$</code> so that <code>$p, q$</code> can transition
to <code>$p', q'$</code> via some <code>$α$</code>, and <code>$(p', q') \not \in \mathcal{S}$</code>. But
that can't be the case, since we assumed that <code>$\mathcal{R} \subseteq \mathcal{S}$</code>.
This is a contradiction.</p>

<h2>Chapter 5</h2>

<h3>5.1</h3>

<p><code>$\langle \cdot b \cdot \rangle \{s_1, t_1\}=\{t_1\}$</code></p>

<p><code>$[ \cdot b \cdot ] \{s_1, t_1\}=\{s,t,t_1\}$</code></p>

<h3>5.2</h3>

<h4>1</h4>

<div>
    $$ ⟦ [\text{coffee}] \langle \text{biscuit} \rangle \textit{t}\!\textit{t}⟧=\\
    [\cdot \text{coffee} \cdot ] ⟦ \langle \text{biscuit} \rangle \textit{t}\!\textit{t} ⟧=\\
    [\cdot \text{coffee} \cdot ] \langle \cdot \text{biscuit} \cdot \rangle ⟦\textit{t}\!\textit{t} ⟧=\\
    [\cdot \text{coffee} \cdot ](\langle \cdot \text{biscuit} \cdot \rangle \textbf{Proc})= \\
    [\cdot \text{coffee} \cdot ] \{p \in \textbf{Proc} | p \overset{\text{biscuit}}{\rightarrow} p' \text{ and } p' \in \textbf{Proc} \text{ for some } p'\}= \\
    [\cdot \text{coffee} \cdot ] \{p \in \textbf{Proc} | p \overset{\text{biscuit}}{\rightarrow}\} \\
    \{p \in \textbf{Proc} | p \overset{\text{coffee}}{\rightarrow} p' \Rightarrow p' \overset{\text{biscuit}}{\rightarrow}\} $$
</div>

<p>An element would exactly not be in that set if the computer scientist
were to not eat a biscuit after drinking coffee.</p>

<h4>2</h4>

<ul>
<li><code>$(\langle \text{coffee} \rangle \textit{t}\!\textit{t}) \lor (\langle \text{tea} \rangle \textit{t}\!\textit{t})$</code></li>
<li><code>$(\langle \text{coffee} \rangle \textit{t}\!\textit{t}) \land ([ \text{tea} ] \textit{f}\!\textit{f})$</code></li>
<li><code>$[\text{coffee}] [\text{coffee}] \langle \text{tea} \rangle \textit{t}\!\textit{t}$</code></li>
</ul>

<h4>3</h4>

<ul>
<li><code>$\langle a \rangle \textit{f}\!\textit{f}$</code>: It is not possible to perform action <code>$\text{a}$</code> now, since there is no <code>$p' \in \emptyset$</code></li>
<li><code>$[a] \textit{t}\!\textit{t}$</code>: This is trivially true for every process: if you can perform action <code>$\text{a}$</code>, you end up in <code>$\textbf{Proc}$</code></li>
</ul>

<h3>5.3</h3>

<h4>1</h4>

<ul>
<li><code>$s \overset{?}{\models} \langle a \rangle \textit{t}\!\textit{t}$</code> : ✓</li>
<li><code>$s \overset{?}{\models} \langle b \rangle \textit{t}\!\textit{t}$</code> : ✗</li>
<li><code>$s \overset{?}{\models} [a] \textit{f}\!\textit{f}$</code> : ✗ (e.g. <code>$s_1 \not \in \emptyset$</code>)</li>
<li><code>$s \overset{?}{\models} [b] \textit{f}\!\textit{f}$</code> : ✓ (all quantification with no elements automatically right)</li>
<li><code>$s \overset{?}{\models} [ a ] \langle b \rangle \textit{t}\!\textit{t}$</code> : ✓</li>
<li><code>$s \overset{?}{\models} \langle a \rangle \langle b \rangle \textit{t}\!\textit{t}$</code> : ✗ (<code>$s_2$</code> can proceed with <code>$b$</code>)</li>
<li><code>$s \overset{?}{\models} [ a ] \langle a \rangle [a] [b] \textit{f}\!\textit{f}$</code> : ✓ (<code>$[ a ] \langle a \rangle [a]$</code> ends up at <code>$s$</code> again, which has no <code>$b$</code> transitions, and an all quantification with no elements is automatically correct, even over unsatisfiable propositions like <code>$s_1 \in \emptyset$</code>)</li>
<li><code>$s \overset{?}{\models} \langle a \rangle (\langle a \rangle \textit{t}\!\textit{t} \land \langle b \rangle \textit{t}\!\textit{t})$</code> : ✗ (it is not possible to <code>$b$</code>-transition from <code>$s_2$</code>)</li>
<li><code>$s \overset{?}{\models} [ a ] (\langle a \rangle \textit{t}\!\textit{t} \lor \langle b \rangle \textit{t}\!\textit{t})$</code> : ✓</li>
<li><code>$s \overset{?}{\models} \langle a \rangle ([b][a] \textit{f}\!\textit{f} \land \langle b \rangle \textit{t}\!\textit{t})$</code> : ✗ (it's impossible to transition from <code>$s_2$</code> via <code>$b$</code>)</li>
<li><code>$s \overset{?}{\models} \langle a \rangle ([a] (\langle a \rangle \textit{t}\!\textit{t} \land [ b ] \textit{f}\!\textit{f}) \land \langle b \rangle \textit{f}\!\textit{f})$</code> : ✗ (since one can transition to <code>$s_1$</code> via <code>$a$</code>, and one can transition from <code>$s_1$</code> via <code>$b$</code>, which violates the <code>$\langle b \rangle \textit{f}\!\textit{f}$</code>)</li>
</ul>

<h4>2</h4>

<ul>
<li><code>$⟦[a][b]\textit{f}\!\textit{f}⟧=[\cdot a \cdot][\cdot b \cdot]\emptyset=[\cdot a \cdot]\{s, s_2, s_3, s_4\}=\{s_2, s_3, s_4\}$</code></li>
<li><code>$⟦(\langle a \rangle (\langle a \rangle \textit{t}\!\textit{t} \land \langle b \rangle \textit{t}\!\textit{t})⟧=\langle \cdot a \cdot \rangle (⟦\langle a \rangle \textit{t}\!\textit{t}⟧ \cap ⟦\langle b \rangle \textit{t}\!\textit{t}⟧)=\langle \cdot a \cdot \rangle (\{s, s_1, s_2, s_3, s_4\} \cap \{s_1\})=\langle \cdot a \cdot \rangle \{s_1\}=\{s\}$</code></li>
<li><code>$⟦[a][a][b] \textit{f}\!\textit{f}⟧=[\cdot a \cdot][\cdot a \cdot][\cdot b \cdot] \emptyset=[\cdot a \cdot][\cdot a \cdot]\{s, s_2, s_3, s_4\}=[\cdot a \cdot]\{s_2, s_3, s_4\}=\{s_2\}$</code></li>
<li><code>$⟦[a][a][b] \textit{f}\!\textit{f}⟧=[\cdot a \cdot] \textbf{Proc}=\{s, s_1, s_2, s_3, s_4\}$</code></li>
</ul>

<!--
TODO
### 5.5

It's MANDATORY
-->
</html>
